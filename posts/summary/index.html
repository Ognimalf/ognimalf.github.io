<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>软件构造课程知识点总结 | Salieri&#39;s Blog</title>
<meta name="keywords" content="软件构造" />
<meta name="description" content="软件构造知识点总结。主要是为了复习用，因此没有太注意格式。
1. 多维度视图 阶段: 构造时/运行时视图
动态性: 时刻/阶段视图
构造对象的层次: 代码/构件视图
重点，一定要记。
构造阶段：
 时刻视图：特定时刻的软件形态 阶段视图：软件形态随时间变化 代码视图：代码的逻辑组织 构件视图：代码的物理组织  运行时阶段：
 时刻视图：逻辑/物理实体在内存/硬件环境中特定时刻的形态如何 阶段视图：逻辑/物理实体在内存/硬件环境中的形态随时间如何变化 代码视图：逻辑实体在内存中如何呈现 构件视图：物理实体在物理硬件环境中如何呈现  软件系统的质量因素 外部质量取决于内部质量
外部质量因素 影响用户
 正确性：最重要的指标 健壮性 可扩展性 可复用性 兼容性 性能 可移植性  正确性与健壮性：可靠性
可扩展性与可复用性：模块性
其他因素：易用性，功能性，及时性，可验证性，完整性，可修复性，经济型
内部质量因素 可读性，可理解性，Clearness，规模，复杂度
内部质量因素通常用作测量外部质量因素的部分指标
2. 软件测试 残留缺陷率：每一千行代码残留的bug
 1-10：典型行业软件 0.1-1：高质量的验证，java 库可能达到这个级别 0.01-0.1：非常好，安全的验证。NASA 与 Praxis 这类公司可能达到的级别  单元测试，集成测试，系统测试，回归测试。
静态测试，动态测试：靠眼睛看/实际运行程序执行测试样例
assertEquals(expected, actual); 黑盒与白盒测试 黑盒测试：对程序外部表现出来的行为进行测试
黑盒测试检查的错误类型：
 错误或缺失的功能 接口错误 数据结构的错误或者外部数据库连接错误 行为或性能错误 初始化或终止错误  黑盒测试样例依照规约与方法要求构造，检查程序是否符合规约">
<meta name="author" content="">
<link rel="canonical" href="https://ognimalf.github.io/posts/summary/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.61dfb3f0b4cda95d2ccb867f9a3b244ce5d23e12492bcc3c277df594c7bc1adf.css" integrity="sha256-Yd&#43;z8LTNqV0sy4Z/mjskTOXSPhJJK8w8J331lMe8Gt8=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js" integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://ognimalf.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://ognimalf.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://ognimalf.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://ognimalf.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://ognimalf.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.68.3" />
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="软件构造课程知识点总结" />
<meta property="og:description" content="软件构造知识点总结。主要是为了复习用，因此没有太注意格式。
1. 多维度视图 阶段: 构造时/运行时视图
动态性: 时刻/阶段视图
构造对象的层次: 代码/构件视图
重点，一定要记。
构造阶段：
 时刻视图：特定时刻的软件形态 阶段视图：软件形态随时间变化 代码视图：代码的逻辑组织 构件视图：代码的物理组织  运行时阶段：
 时刻视图：逻辑/物理实体在内存/硬件环境中特定时刻的形态如何 阶段视图：逻辑/物理实体在内存/硬件环境中的形态随时间如何变化 代码视图：逻辑实体在内存中如何呈现 构件视图：物理实体在物理硬件环境中如何呈现  软件系统的质量因素 外部质量取决于内部质量
外部质量因素 影响用户
 正确性：最重要的指标 健壮性 可扩展性 可复用性 兼容性 性能 可移植性  正确性与健壮性：可靠性
可扩展性与可复用性：模块性
其他因素：易用性，功能性，及时性，可验证性，完整性，可修复性，经济型
内部质量因素 可读性，可理解性，Clearness，规模，复杂度
内部质量因素通常用作测量外部质量因素的部分指标
2. 软件测试 残留缺陷率：每一千行代码残留的bug
 1-10：典型行业软件 0.1-1：高质量的验证，java 库可能达到这个级别 0.01-0.1：非常好，安全的验证。NASA 与 Praxis 这类公司可能达到的级别  单元测试，集成测试，系统测试，回归测试。
静态测试，动态测试：靠眼睛看/实际运行程序执行测试样例
assertEquals(expected, actual); 黑盒与白盒测试 黑盒测试：对程序外部表现出来的行为进行测试
黑盒测试检查的错误类型：
 错误或缺失的功能 接口错误 数据结构的错误或者外部数据库连接错误 行为或性能错误 初始化或终止错误  黑盒测试样例依照规约与方法要求构造，检查程序是否符合规约" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ognimalf.github.io/posts/summary/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-06-09T22:09:39&#43;09:00" />
<meta property="article:modified_time" content="2022-06-09T22:09:39&#43;09:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="软件构造课程知识点总结"/>
<meta name="twitter:description" content="软件构造知识点总结。主要是为了复习用，因此没有太注意格式。
1. 多维度视图 阶段: 构造时/运行时视图
动态性: 时刻/阶段视图
构造对象的层次: 代码/构件视图
重点，一定要记。
构造阶段：
 时刻视图：特定时刻的软件形态 阶段视图：软件形态随时间变化 代码视图：代码的逻辑组织 构件视图：代码的物理组织  运行时阶段：
 时刻视图：逻辑/物理实体在内存/硬件环境中特定时刻的形态如何 阶段视图：逻辑/物理实体在内存/硬件环境中的形态随时间如何变化 代码视图：逻辑实体在内存中如何呈现 构件视图：物理实体在物理硬件环境中如何呈现  软件系统的质量因素 外部质量取决于内部质量
外部质量因素 影响用户
 正确性：最重要的指标 健壮性 可扩展性 可复用性 兼容性 性能 可移植性  正确性与健壮性：可靠性
可扩展性与可复用性：模块性
其他因素：易用性，功能性，及时性，可验证性，完整性，可修复性，经济型
内部质量因素 可读性，可理解性，Clearness，规模，复杂度
内部质量因素通常用作测量外部质量因素的部分指标
2. 软件测试 残留缺陷率：每一千行代码残留的bug
 1-10：典型行业软件 0.1-1：高质量的验证，java 库可能达到这个级别 0.01-0.1：非常好，安全的验证。NASA 与 Praxis 这类公司可能达到的级别  单元测试，集成测试，系统测试，回归测试。
静态测试，动态测试：靠眼睛看/实际运行程序执行测试样例
assertEquals(expected, actual); 黑盒与白盒测试 黑盒测试：对程序外部表现出来的行为进行测试
黑盒测试检查的错误类型：
 错误或缺失的功能 接口错误 数据结构的错误或者外部数据库连接错误 行为或性能错误 初始化或终止错误  黑盒测试样例依照规约与方法要求构造，检查程序是否符合规约"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "软件构造课程知识点总结",
      "item": "https://ognimalf.github.io/posts/summary/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "软件构造课程知识点总结",
  "name": "软件构造课程知识点总结",
  "description": "软件构造知识点总结。主要是为了复习用，因此没有太注意格式。\n1. 多维度视图 阶段: 构造时/运行时视图\n动态性: 时刻/阶段视图\n构造对象的层次: 代码/构件视图\n重点，一定要记。\n构造阶段：\n 时刻视图：特定时刻的软件形态 阶段视图：软件形态随时间变化 代码视图：代码的逻辑组织 构件视图：代码的物理组织  运行时阶段：\n 时刻视图：逻辑/物理实体在内存/硬件环境中特定时刻的形态如何 阶段视图：逻辑/物理实体在内存/硬件环境中的形态随时间如何变化 代码视图：逻辑实体在内存中如何呈现 构件视图：物理实体在物理硬件环境中如何呈现  软件系统的质量因素 外部质量取决于内部质量\n外部质量因素 影响用户\n 正确性：最重要的指标 健壮性 可扩展性 可复用性 兼容性 性能 可移植性  正确性与健壮性：可靠性\n可扩展性与可复用性：模块性\n其他因素：易用性，功能性，及时性，可验证性，完整性，可修复性，经济型\n内部质量因素 可读性，可理解性，Clearness，规模，复杂度\n内部质量因素通常用作测量外部质量因素的部分指标\n2. 软件测试 残留缺陷率：每一千行代码残留的bug\n 1-10：典型行业软件 0.1-1：高质量的验证，java 库可能达到这个级别 0.01-0.1：非常好，安全的验证。NASA 与 Praxis 这类公司可能达到的级别  单元测试，集成测试，系统测试，回归测试。\n静态测试，动态测试：靠眼睛看/实际运行程序执行测试样例\nassertEquals(expected, actual); 黑盒与白盒测试 黑盒测试：对程序外部表现出来的行为进行测试\n黑盒测试检查的错误类型：\n 错误或缺失的功能 接口错误 数据结构的错误或者外部数据库连接错误 行为或性能错误 初始化或终止错误  黑盒测试样例依照规约与方法要求构造，检查程序是否符合规约",
  "keywords": [
    "软件构造"
  ],
  "articleBody": "软件构造知识点总结。主要是为了复习用，因此没有太注意格式。\n1. 多维度视图 阶段: 构造时/运行时视图\n动态性: 时刻/阶段视图\n构造对象的层次: 代码/构件视图\n重点，一定要记。\n构造阶段：\n 时刻视图：特定时刻的软件形态 阶段视图：软件形态随时间变化 代码视图：代码的逻辑组织 构件视图：代码的物理组织  运行时阶段：\n 时刻视图：逻辑/物理实体在内存/硬件环境中特定时刻的形态如何 阶段视图：逻辑/物理实体在内存/硬件环境中的形态随时间如何变化 代码视图：逻辑实体在内存中如何呈现 构件视图：物理实体在物理硬件环境中如何呈现  软件系统的质量因素 外部质量取决于内部质量\n外部质量因素 影响用户\n 正确性：最重要的指标 健壮性 可扩展性 可复用性 兼容性 性能 可移植性  正确性与健壮性：可靠性\n可扩展性与可复用性：模块性\n其他因素：易用性，功能性，及时性，可验证性，完整性，可修复性，经济型\n内部质量因素 可读性，可理解性，Clearness，规模，复杂度\n内部质量因素通常用作测量外部质量因素的部分指标\n2. 软件测试 残留缺陷率：每一千行代码残留的bug\n 1-10：典型行业软件 0.1-1：高质量的验证，java 库可能达到这个级别 0.01-0.1：非常好，安全的验证。NASA 与 Praxis 这类公司可能达到的级别  单元测试，集成测试，系统测试，回归测试。\n静态测试，动态测试：靠眼睛看/实际运行程序执行测试样例\nassertEquals(expected, actual); 黑盒与白盒测试 黑盒测试：对程序外部表现出来的行为进行测试\n黑盒测试检查的错误类型：\n 错误或缺失的功能 接口错误 数据结构的错误或者外部数据库连接错误 行为或性能错误 初始化或终止错误  黑盒测试样例依照规约与方法要求构造，检查程序是否符合规约\n白盒测试：对程序内部代码结构的测试\n白盒测试需要考虑内部实现细节，依据程序执行路径设计测试用例，一般较早执行\n白盒测试可以设计如下特点的测试用例：\n 保证所有路径至少被执行过一次 所有的逻辑分支 true 与 false 的情况都被执行过 所有的循环的边界条件都被执行过 测试内部数据结构保证它们的有效性。  独立/基本路径测试(白盒测试的一种)：对程序所有执行路径进行等价类划分，找出有代表性的最简单的路径(例如循环只需执行1次)，设计测试用例使每一条基本路径被至少覆盖一次。\n代码覆盖度 几种代码覆盖度类型：\n 函数覆盖 语句覆盖 分支覆盖 条件覆盖 路径覆盖：比如说，一个循环需要20次，循环内有5条路线，那么总的路径数目是$5^{20}$次。  评估代码覆盖度：EclEmma，jacoco\n自动测试与回归测试 自动测试指测试用例的自动执行，而不是自动生成测试用例。\n回归测试：一旦程序被修改，就重新执行之前的所有测试。\n软件: Travis-CI\n测试策略,等价类划分,黑盒白盒等等.\n3. 软件构造过程与配置管理 软件开发基本过程 计划 - 分析 - 设计 - 实现 - 测试与集成 - 维护\n传统的软件设计模型 线性过程，迭代过程，瀑布过程，增量过程，V字过程，原型过程，螺旋过程\n瀑布过程：无迭代，无法适应需求，增加/变化\n增量过程：多个瀑布串行，无迭代，比较容易适应需求\n敏捷开发 增量+迭代\n软件配置管理(SCM)与版本控制系统(VCS) 软件配置管理：追踪和控制软件的变化\n软件配置项：软件中发生变化的基本单元(例如：文件，源代码，数据，硬件，各种环境)\nbaseline：软件持续变化过程中的稳定时刻(例如：对外发布的版本)\nCMDB(配置管理数据库)：存储软件的各配置项随时间发生变化的信息+baseline\nRepository(仓库)：在SCM中的CMDB\ngit git仓库有三部分：\n .git 目录：本地的CMDB 工作目录：本地文件系统 暂存区：隔离工作目录与 git 仓库  每个文件都属于下面三种状态之一：\n 已修改：工作目录中的文件与仓库中的文件不同，但是并没有在暂存区中 已暂存：文件被修改且被添加到暂存区 已提交：工作目录中的文件与仓库中的文件一致  变化管理：\n 传统的版本控制系统：存储版本之间的变化(行) git 存储发生变化的文件(而不是代码行)，不变化的文件不重复存储  软件构造的一般过程 编码 - 构建(build) - 代码评审 - 性能分析 - 测试 - 调试 - 重构\n静态代码分析工具：CheckStyle，SpotBugs，PMD\n动态代码分析工具：visualVM，Java profiler\n软件: jenkins, ant, maven, gradle, travis\n4. 类型检查 静态类型检查，主要关注类型：\n 语法错误 类名/函数名错误 参数数目错误 参数类型错误 返回值类型错误  动态类型检查，主要关注值：\n 非法的参数值 非法的返回值 越界 空指针  Java中的数值类型：\n 整数除法,并不会产生动态错误,只会造成错误的结果 整数溢出 浮点类型的特殊值:POSITIVE_INFINITY与NEGATIVE_INFINITY.像除数为0或者负数开方这类运算,并不会产生错误.而是产生特殊值,如果使用这个结果继续运算才会中止程序  mutability, immutability final 关键字使一个引用不可变。\n final 类无法派生子类 final 变量无法改变值/引用 final 方法无法被子类重写，但是可以重载  防御式拷贝，方法返回全新的对象。避免用户修改原本对象的数据\n如果使用不可变类型，节省频繁复制的代价\nsnapshot diagram 基本类型的值用普通的指向，对象类型要画圈\n可变对象：普通单线圆\n不可变对象：双线圆\n可变的引用：单线箭头\n不可变引用：双线箭头\nunmodifiable wrappers\n基本类型及其封装对象类型都是不可变的。\n5. 设计规约 两个函数虽然行为不一定等价，但是如果站在用户的视角来说，行为可以是等价的。\n规约的内容\n规约强度判断\n非常重要的一点：抛出异常减弱后置条件\n规约类型\n静态分析工具：FindBugs\n6. ADT(抽象数据类型) 表示独立性\n表示泄露\n使用防御式拷贝避免 mutate 成员引用暴露给用户\n方法四种类型:\n creator(构造器)：使用其他类型参数构造对象，$t^* \\rarr T$ producer(生产器)：可以使用本类型构造对象，$T+,t^* \\rarr T$ observer(观察器)：返回一个不同类型的对象，$T+,t^* \\rarr t$ mutator(变值器)：修改内部的 rep，$T+,t^* \\rarr void ;|; t ;|; T$  RI 与 AF ADT 开发者关注表示空间 R，用户关注抽象空间 A。\n抽象函数 AF必须是满射(即对每个 A 中的值，都有 R 中的值对应)，不一定是单射，也不一定是双射\n表示不变性 RI：\n 某个具体的“表示”是否合法 所有表示值的一个子集，包含了所有合法的表示值 一个条件，描述了什么是合法的表示值  在所有可能改变 rep 的方法内部都需要检查 RI 是否满足，Observer 方法看情况。\n对immutable的ADT来说，它在A空间的abstract value应是不变的。但其内部表示的R空间中的取值则可以是变化的，从这个角度来说，immutable 的 ADT 内部的 rep 是可以变化的。\n代码中以注释形式写出 AF 与 RI 而不能在 javadoc 文档中，避免外部破坏。\n7. oop 静态方法与实例方法\n继承\n重写与重载\n多态 Ad-hoc 多态(特殊多态)：函数重载\n参数化多态：使用泛型\n子类型多态\n重载与重写的区别:\n 重载只是保持函数名字相同,函数参数,返回值,行为都可以不同 重写是子类型重写父类型的方法,函数签名一致,严格的编程规范要求子类型的实现规约强度大于等于父类型的实现 重载(overload)在编译阶段决定具体执行哪个方法,重写(overridden/overwrite)在运行时决定.  重载:\n 必须要求不同的参数列表 返回值类型不做要求 权限不做要求(private, public, protected) 抛出异常不做要求 可以在同一个类内重载，也可以在子类中重载  注意: 在决定重载函数类型时,对于object参数类型的比较是基于静态类型,即编译时确定的类型,而不是对象实际的动态类型.\njava @override (重写):\n 参数列表必须完全相同，传入参数不能是父类型或子类型 返回类型与被重写方法返回类型可以不相同，但必须是父类返回值的派生类。 访问权限比父类方法更高 关于异常:\n可以减少抛出的异常,这样说明子类型的实现后置条件相对于父类型更强,规约也更强.\n不能抛出新的或者范围更广的异常,这样说明子类型不能处理这些输入,而父类型可以,规约强度减弱. 声明为 static 的方法不能被重写，但是能够被再次声明。  对象静态类型与动态类型\n8. ADT 与 OOP 中的等价性 等价关系：自反，对称，传递\n不可变类型的等价性  使用抽象函数判断等价性。 以观察者的角度：对两个对象调用任何相同的操作，结果相同，就认为等价。  注意,Java中,==是引用相等,它判断两个引用是否指向相同的对象,而equals()则比较两个对象是否相等.Java中equals()的默认实现是引用相等运算.\n重写equals()的注意事项:\n equals必须是一个等价关系.(非常重要,必须遵守) equals的结果必须一致,重复调用必须时必须产生相同的结果 对于非空的引用,x.equals(null)应该返回false 两个对象在equals方法中被认为相等,那么它们在hashCode中的结果也应该被认为相等.  一个重要的准则:\n Always override hashCode when you override equals.\n java 根据静态类型选择最合适的函数。\n严格来说，在没有AF的情况下直接在equals()中判断每个域的等价性，是不正确的\ninstanceof Java中对于不同静态类型,而动态类型相同的相等运算,可能会产生错误.因此在实现时需要注意.我们可以使用instanceof关键字来获取对象的动态类型,但是除了equals()实现,在其他任何情况都应该避免使用.\n使用 instanceof 是动态类型检查。\nhashCode hashCode 的默认实现返回对象内存地址。\n可以使用 Objects.hash() 方法：\npublic static int hash(Object... values) { return Arrays.hashCode(values); } 可以将不可变类型的对象的成员变量传入，按照 Objects 数组的方式计算哈希值，这是一种重写 hashCode() 的方法。\n可变类型的等价性 类似于不可变类型,对于可变类型,我们重新定义两种基于观察的等价性判别方法:\n 观察等价性：在不改变状态的情况下，两个 mutable 对象是否看起来一致 行为等价性：调用对象的任何方法都展示出一致的结果。  这部分理解感觉还有点困难。\n* 这部分的甄别比较重要\nJava中,List,Set,Map等Collections使用观察等价性,而其他可变类如StringBuilder和数组,使用行为等价性。\n例子：\n// 注意，虽然前面说 collections使用观察等价性，但是这里的代码是可以正常运行的。即使在之后往 list 中添加了其他的元素，对象前后的状态改变了 public static void main (String[] argv) { ListString list = new ArrayList(); SetListString test = new HashSet(); list.add(\"a\"); test.add(list); assert test.contains(list); list.add(\"google\"); assert test.contains(list); } 一般来说，对于可变类型，不需要重写 equals() 与 hashCode()。\n基本类型的包装 9. 面向复用的软件构造技术 复用：源代码级别，模块级别，库级别，系统级别\n最主要的复用在代码层面\n需求，设计/规约，数据，测试用例，文档等等都可以被复用\n白盒复用：源代码可见，可修改可扩展。可定制化程度高\n黑盒复用：源代码不可见，不能修改。通过简单的 API 接口使用，不能修改代码\n工具：javap 获得类的公共方法头\n    白盒框架 黑盒框架     扩展方式 通过代码层面的继承进行框架扩展 通过实现特定接口/委派进行框架扩展   设计模式 模板方法模式 策略模式，观察者模式    LSP 原则 设计实现子类型多态时需要遵循的原则。\n核心：子类型的规约强度必须强于父类型或与父类型一致。\n更强的规约就要求：\n 更强的不变量 更弱的前置条件 更强的后置条件  要求：\n 子类型可以增加方法，但不能删除 子类型需要实现抽象类型中的所有未实现方法 子类型中重写的方法必须有相同类型的返回值或者符合 co-variance 的返回值 子类型中重写的方法必须使用同类型的参数或者符合逆变的参数 子类型中重写的方法不能抛出额外的异常，抛出相同或者符合协变的异常  父类型 - 子类型：越来越具体\n协变：返回值，异常类型不变或更具体\n反协变，逆变：返回值，异常类型不变或越来越抽象\n注意，java 中对于函数参数的逆变通常看做重载，即 overload\n泛型中的 LSP 注意，泛型不是协变。\n由于存在类型擦除，因此运行时无法利用泛型参数进行类型推断。\n重要的例子\n List is a subtype of List List is a subtype of List List is a subtype of List  Delegation and Composition 委派模式：通过运行时的动态类型绑定，实现对其他类中代码的复用。\n委派简单来说，就是在一个类 A 中定义另一个类类型的成员变量 B，通过调用 B 的方法来实现想要的功能。\n与继承相比，委派发生在 object 层面，而继承发生在 class 层面。\nCRP 原则：在实现多态行为时，类应该选择持有实现需要的方法的类的实例，而不是在实现对应方法的类的基础上进行继承。简单来说，就是尽可能选择 has 或者 use 而不是 is 的方式。\nCRP 原则更倾向于使用委派而不是继承来实现复用。\nTypes of delegation  Dependency：临时性委派，即在程序过程中创建临时变量作为方法参数传递。 Association：永久性委派，在类中定义成员进行使用。 Composition：更强的 association，构造对象时直接创建对应的委派对象实例。 Aggregation：更弱的 association，在类中定义成员，在程序过程中使用类似于 set() 方法来设置成员变量，从而实现委派。  Compositon 中，委派对象与本体会同时被破坏；但是在 Aggregation 中，委派对象的生命周期可能更长。\n10. 面向可维护性的构造技术 MI(可维护性指数)影响因素：HV(Halstead Volume)，CC(代码圈复杂度)，LOC(模块平均代码行数)，COM(模块平均注释行数)\n模块设计及设计原则 评估模块化的5个标准：可分解性，可组合性，可理解性，可持续性(变化时受影响范围最小)，异常保护(出现异常后受影响范围最小)\n模块化设计的5条规则：直接映射，尽可能少的接口，尽可能小的接口，显式接口，信息隐藏\ncouping(耦合)与 cohesion(内聚) 耦合评估模块间的依赖程度。\n内聚评估模块内功能或职责的关联程度。\n软件开发追求高内聚，低耦合。\n面向对象的设计原则：SOLID  SRP(单一责任原则)：不应该由多于一个原因使 ADT 发生变化，否则就需要拆分 ADT。 OCP(开放/封闭原则)：对扩展性的开放，对修改的封闭 LSP：子类型必须能够替换基类型 ISP(接口隔离原则)：不能强迫客户端依赖于不需要的接口，只提供必需的接口 DIP(依赖转置原则)：抽象的模块不应该依赖于具体的模块。例：在实现委派的时候，通过接口建立联系，而不是直接定义对应类型的对象  11. 设计模式 1. 创建型模式 工厂方法模式 使用场景：用户不知道创建哪个具体类的实例，或者不想再代码中指明要具体创建的实例时，可以使用工厂方法。\n定义一个用于创建对象的接口，让其子类来决定实例化哪一个类，从而使类的实例化延迟到子类。\n实现方法，定义一个工厂接口，工厂类中实现对应构造对象的方法。\n符合 OCP 原则：对扩展开放，对修改已有代码封闭\n2. 结构性模式 适配器 作用：将某个类/接口转换为用户期望的其他形式\n实现方法：通过增加一个接口，将已存在的子类封装起来，用户面向接口编程，从而隐藏了具体子类。\n装饰器 用每个子类实现不同的特性\n实现方法：首先构造一个基类实现接口，接着构造一个装饰器类实现接口，装饰器类通过委派给基类的方式实现接口的方法。然后继承装饰器并在此基础上添加额外的功能。\n3.行为类模式 策略模式 使用场景：有多种不同的算法实现同一个任务，但需要用户根据需要动态切换算法，而不是写死在代码中\n实现方法：为不同的实现算法构造抽象接口，利用委派，运行时动态传入用户倾向的算法类实例。\n模板模式 做事情的步骤一样，但是具体方法不同。\n实现方法：共性的步骤在抽象类内公共实现，差异化的步骤在各个子类中实现\n使用继承与重写实现模板模式\n迭代器 使用场景：客户端希望遍历容器中的 ADT 对象，不关注容器具体类型\njava 实现：\n 需要实现继承 Iterable 接口的迭代器类，并且内部委派一个实现 Iterator 接口的类的对象。 Iterator 接口需要实现 hasNext(), next()，remove()(可选) 两/三个方法。  访问者模式 对特定类型的对象的特定操作，运行时将两者动态绑定到一起，该操作可以灵活更改，无需更改被访问的类。\n访问者模式本质上将数据和作用在数据上的某些特定操作分离。\n访问者模式可以为 ADT 预留一个将来可扩展功能的接入点，外部实现的功能代码可以在不改变 ADT 本身的情况下通过委派接入 ADT。\n实现方法(示例)：\n 定义一个 Visitor 接口，包含 visit() 方法。 再定义一个 Accepter 接口，包含 accept() 方法。该方法传入一个 Visitor 参数。 将需要被访问的类实现 Accepter 接口，accept() 方法内部调用 Visitor.visit(this)。 visit() 实现对访问对象的具体操作。  注意：访问者模式也只能够使用对象的 public 成员与方法，对于私有成员/方法没有权限。\n与策略模式的区别：\n访问者模式站在外部用户的角度，灵活增加对 ADT 的不同操作。\n策略模式是站在内部 ADT 的角度，对 ADT 的方法提供不同的实现策略，强调相应算法的灵活替换，这些算法被委派到外部的策略类中。\n12. 面向正确性与健壮性的软件构造 正确性：永不给用户错误的结果，倾向于直接报错\n健壮性：尽可能保证软件运行而不是总退出，倾向于容错\n对外的接口，倾向于健壮；对内的接口，倾向于正确\n外部观察角度：MTBF(平均失效间隔时间)\n内部观察角度\nResidual defect rates(残余缺陷率)\nKLOC：每千代码中遗留 bug 数量\n异常处理 RuntimeException：运行时异常，unchecked，继承自 Exception，不需要被捕获。\n如果父类型中的方法没有抛出异常，那么子类型中的方法必须捕获所有的checked exception。\nfinal 在抛出异常之后，方法中正常执行的代码被终止。一些申请过的资源需要被清理。这时我们可以使用 final。无论程序中是否有异常，final 块中的代码一定会被执行。\n一个重要的例子：\nstatic boolean decision() { try { System.out.println(\"here\"); return true; } finally { System.out.println(\"return\"); return false; } } public static void main(String[] argv) { System.out.println(decision()); } 最后的输出：\nhere return false assertion 检查前置条件是防御式编程的一种典型形式\n在实际使用时，assertion 都会被 disabled\nassert condition : message; 在 assertion 错误时会显示 message。\nassertion 主要用于开发阶段，避免引入和帮助发现bug。在开发时 assertion 编译入代码，生产中从代码剥离，因此不会降低性能。assertion 非常影响运行时性能。\nassertion - 正确性\nexception - 健壮性\n防御式编程  排除非法输入 assertions exceptions specific error handling techniques barricade debugging aids  工具： FindBugs，SpotBugs。都是使用静态代码分析找出程序中的 bug。\n",
  "wordCount" : "700",
  "inLanguage": "en",
  "datePublished": "2022-06-09T22:09:39+09:00",
  "dateModified": "2022-06-09T22:09:39+09:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://ognimalf.github.io/posts/summary/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Salieri's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://ognimalf.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://ognimalf.github.io" accesskey="h" title="Salieri&#39;s Blog (Alt + H)">Salieri&#39;s Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://ognimalf.github.io/categories/" title="categories">
                    <span>categories</span>
                </a>
            </li>
            <li>
                <a href="https://ognimalf.github.io/tags/" title="tags">
                    <span>tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://ognimalf.github.io">Home</a></div>
    <h1 class="post-title">
      软件构造课程知识点总结
    </h1>
    <div class="post-meta"><span title='2022-06-09 22:09:39 +0900 KST'>June 9, 2022</span>

</div>
  </header> 
  <div class="post-content"><p>软件构造知识点总结。主要是为了复习用，因此没有太注意格式。</p>
<h2 id="1-多维度视图">1. 多维度视图<a hidden class="anchor" aria-hidden="true" href="#1-多维度视图">#</a></h2>
<p>阶段: 构造时/运行时视图</p>
<p>动态性: 时刻/阶段视图</p>
<p>构造对象的层次: 代码/构件视图</p>
<p><strong>重点，一定要记</strong>。</p>
<p>构造阶段：</p>
<ul>
<li>时刻视图：特定时刻的软件形态</li>
<li>阶段视图：软件形态随时间变化</li>
<li>代码视图：代码的逻辑组织</li>
<li>构件视图：代码的物理组织</li>
</ul>
<p>运行时阶段：</p>
<ul>
<li>时刻视图：逻辑/物理实体在内存/硬件环境中特定时刻的形态如何</li>
<li>阶段视图：逻辑/物理实体在内存/硬件环境中的形态随时间如何变化</li>
<li>代码视图：逻辑实体在内存中如何呈现</li>
<li>构件视图：物理实体在物理硬件环境中如何呈现</li>
</ul>
<h3 id="软件系统的质量因素">软件系统的质量因素<a hidden class="anchor" aria-hidden="true" href="#软件系统的质量因素">#</a></h3>
<p>外部质量取决于内部质量</p>
<h4 id="外部质量因素">外部质量因素<a hidden class="anchor" aria-hidden="true" href="#外部质量因素">#</a></h4>
<p>影响用户</p>
<ul>
<li>正确性：最重要的指标</li>
<li>健壮性</li>
<li>可扩展性</li>
<li>可复用性</li>
<li>兼容性</li>
<li>性能</li>
<li>可移植性</li>
</ul>
<p>正确性与健壮性：可靠性<br>
可扩展性与可复用性：模块性</p>
<p>其他因素：易用性，功能性，及时性，可验证性，完整性，可修复性，经济型</p>
<h4 id="内部质量因素">内部质量因素<a hidden class="anchor" aria-hidden="true" href="#内部质量因素">#</a></h4>
<p>可读性，可理解性，Clearness，规模，复杂度</p>
<p>内部质量因素通常用作测量外部质量因素的部分指标</p>
<h2 id="2-软件测试">2. 软件测试<a hidden class="anchor" aria-hidden="true" href="#2-软件测试">#</a></h2>
<p>残留缺陷率：每一千行代码残留的bug</p>
<ul>
<li>1-10：典型行业软件</li>
<li>0.1-1：高质量的验证，java 库可能达到这个级别</li>
<li>0.01-0.1：非常好，安全的验证。NASA 与 Praxis 这类公司可能达到的级别</li>
</ul>
<p>单元测试，集成测试，系统测试，回归测试。</p>
<p>静态测试，动态测试：靠眼睛看/实际运行程序执行测试样例</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">assertEquals<span style="color:#f92672">(</span>expected<span style="color:#f92672">,</span> actual<span style="color:#f92672">);</span>
</code></pre></div><h3 id="黑盒与白盒测试">黑盒与白盒测试<a hidden class="anchor" aria-hidden="true" href="#黑盒与白盒测试">#</a></h3>
<p>黑盒测试：对程序外部表现出来的行为进行测试</p>
<p>黑盒测试检查的错误类型：</p>
<ul>
<li>错误或缺失的功能</li>
<li>接口错误</li>
<li>数据结构的错误或者外部数据库连接错误</li>
<li>行为或性能错误</li>
<li>初始化或终止错误</li>
</ul>
<p>黑盒测试样例依照规约与方法要求构造，检查程序是否符合规约</p>
<p>白盒测试：对程序内部代码结构的测试</p>
<p>白盒测试需要考虑内部实现细节，依据程序执行路径设计测试用例，一般较早执行</p>
<p>白盒测试可以设计如下特点的测试用例：</p>
<ul>
<li>保证所有路径至少被执行过一次</li>
<li>所有的逻辑分支 true 与 false 的情况都被执行过</li>
<li>所有的循环的边界条件都被执行过</li>
<li>测试内部数据结构保证它们的有效性。</li>
</ul>
<p>独立/基本路径测试(白盒测试的一种)：对程序所有执行路径进行等价类划分，找出有代表性的最简单的路径(例如循环只需执行1次)，设计测试用例使每一条基本路径被至少覆盖一次。</p>
<h3 id="代码覆盖度">代码覆盖度<a hidden class="anchor" aria-hidden="true" href="#代码覆盖度">#</a></h3>
<p>几种代码覆盖度类型：</p>
<ul>
<li>函数覆盖</li>
<li>语句覆盖</li>
<li>分支覆盖</li>
<li>条件覆盖</li>
<li>路径覆盖：比如说，一个循环需要20次，循环内有5条路线，那么总的路径数目是$5^{20}$次。</li>
</ul>
<p>评估代码覆盖度：EclEmma，jacoco</p>
<h3 id="自动测试与回归测试">自动测试与回归测试<a hidden class="anchor" aria-hidden="true" href="#自动测试与回归测试">#</a></h3>
<p>自动测试指测试用例的自动执行，而不是自动生成测试用例。</p>
<p>回归测试：一旦程序被修改，就重新执行之前的所有测试。</p>
<p>软件: Travis-CI</p>
<p>测试策略,等价类划分,黑盒白盒等等.</p>
<h2 id="3-软件构造过程与配置管理">3. 软件构造过程与配置管理<a hidden class="anchor" aria-hidden="true" href="#3-软件构造过程与配置管理">#</a></h2>
<h3 id="软件开发基本过程">软件开发基本过程<a hidden class="anchor" aria-hidden="true" href="#软件开发基本过程">#</a></h3>
<p>计划 -&gt; 分析 -&gt; 设计 -&gt; 实现 -&gt; 测试与集成 -&gt; 维护</p>
<h3 id="传统的软件设计模型">传统的软件设计模型<a hidden class="anchor" aria-hidden="true" href="#传统的软件设计模型">#</a></h3>
<p>线性过程，迭代过程，瀑布过程，增量过程，V字过程，原型过程，螺旋过程</p>
<p>瀑布过程：无迭代，无法适应需求，增加/变化</p>
<p>增量过程：多个瀑布串行，无迭代，比较容易适应需求</p>
<h3 id="敏捷开发">敏捷开发<a hidden class="anchor" aria-hidden="true" href="#敏捷开发">#</a></h3>
<p>增量+迭代</p>
<h3 id="软件配置管理scm与版本控制系统vcs">软件配置管理(SCM)与版本控制系统(VCS)<a hidden class="anchor" aria-hidden="true" href="#软件配置管理scm与版本控制系统vcs">#</a></h3>
<p>软件配置管理：追踪和控制软件的变化</p>
<p>软件配置项：软件中发生变化的基本单元(例如：文件，源代码，数据，硬件，各种环境)</p>
<p>baseline：软件持续变化过程中的稳定时刻(例如：对外发布的版本)</p>
<p>CMDB(配置管理数据库)：存储软件的各配置项随时间发生变化的信息+baseline</p>
<p>Repository(仓库)：在SCM中的CMDB</p>
<h3 id="git">git<a hidden class="anchor" aria-hidden="true" href="#git">#</a></h3>
<p>git仓库有三部分：</p>
<ul>
<li>.git 目录：本地的CMDB</li>
<li>工作目录：本地文件系统</li>
<li>暂存区：隔离工作目录与 git 仓库</li>
</ul>
<p>每个文件都属于下面三种状态之一：</p>
<ul>
<li>已修改：工作目录中的文件与仓库中的文件不同，但是并没有在暂存区中</li>
<li>已暂存：文件被修改且被添加到暂存区</li>
<li>已提交：工作目录中的文件与仓库中的文件一致</li>
</ul>
<p>变化管理：</p>
<ul>
<li>传统的版本控制系统：存储版本之间的变化(行)</li>
<li>git 存储发生变化的文件(而不是代码行)，不变化的文件不重复存储</li>
</ul>
<h3 id="软件构造的一般过程">软件构造的一般过程<a hidden class="anchor" aria-hidden="true" href="#软件构造的一般过程">#</a></h3>
<p>编码 -&gt; 构建(build) -&gt; 代码评审 -&gt; 性能分析 -&gt; 测试 -&gt; 调试 -&gt; 重构</p>
<p>静态代码分析工具：CheckStyle，SpotBugs，PMD</p>
<p>动态代码分析工具：visualVM，Java profiler</p>
<p>软件: jenkins, ant, maven, gradle, travis</p>
<h2 id="4-类型检查">4. 类型检查<a hidden class="anchor" aria-hidden="true" href="#4-类型检查">#</a></h2>
<p>静态类型检查，主要关注类型：</p>
<ul>
<li>语法错误</li>
<li>类名/函数名错误</li>
<li>参数数目错误</li>
<li>参数类型错误</li>
<li>返回值类型错误</li>
</ul>
<p>动态类型检查，主要关注值：</p>
<ul>
<li>非法的参数值</li>
<li>非法的返回值</li>
<li>越界</li>
<li>空指针</li>
</ul>
<p>Java中的数值类型：</p>
<ul>
<li>整数除法,并不会产生动态错误,只会造成错误的结果</li>
<li>整数溢出</li>
<li>浮点类型的特殊值:POSITIVE_INFINITY与NEGATIVE_INFINITY.像除数为0或者负数开方这类运算,并不会产生错误.而是产生特殊值,如果使用这个结果继续运算才会中止程序</li>
</ul>
<h3 id="mutability-immutability">mutability, immutability<a hidden class="anchor" aria-hidden="true" href="#mutability-immutability">#</a></h3>
<p><code>final</code> 关键字使一个引用不可变。</p>
<ul>
<li>final 类无法派生子类</li>
<li>final 变量无法改变值/引用</li>
<li>final 方法无法被子类重写，但是可以重载</li>
</ul>
<p>防御式拷贝，方法返回全新的对象。避免用户修改原本对象的数据</p>
<p>如果使用不可变类型，节省频繁复制的代价</p>
<h3 id="snapshot-diagram">snapshot diagram<a hidden class="anchor" aria-hidden="true" href="#snapshot-diagram">#</a></h3>
<p>基本类型的值用普通的指向，对象类型要画圈</p>
<p>可变对象：普通单线圆<br>
不可变对象：双线圆</p>
<p>可变的引用：单线箭头<br>
不可变引用：双线箭头</p>
<p>unmodifiable wrappers</p>
<p>基本类型及其封装对象类型都是不可变的。</p>
<h2 id="5-设计规约">5. 设计规约<a hidden class="anchor" aria-hidden="true" href="#5-设计规约">#</a></h2>
<p>两个函数虽然行为不一定等价，但是如果站在用户的视角来说，行为可以是等价的。</p>
<p>规约的内容</p>
<p>规约强度判断</p>
<p>非常重要的一点：抛出异常减弱后置条件</p>
<p>规约类型</p>
<p>静态分析工具：FindBugs</p>
<h2 id="6-adt抽象数据类型">6. ADT(抽象数据类型)<a hidden class="anchor" aria-hidden="true" href="#6-adt抽象数据类型">#</a></h2>
<p>表示独立性</p>
<p>表示泄露</p>
<p>使用防御式拷贝避免 mutate 成员引用暴露给用户</p>
<p>方法四种类型:</p>
<ul>
<li>creator(构造器)：使用其他类型参数构造对象，$t^* \rarr T$</li>
<li>producer(生产器)：可以使用本类型构造对象，$T+,t^* \rarr T$</li>
<li>observer(观察器)：返回一个不同类型的对象，$T+,t^* \rarr t$</li>
<li>mutator(变值器)：修改内部的 rep，$T+,t^* \rarr void ;|; t ;|; T$</li>
</ul>
<h3 id="ri-与-af">RI 与 AF<a hidden class="anchor" aria-hidden="true" href="#ri-与-af">#</a></h3>
<p>ADT 开发者关注表示空间 R，用户关注抽象空间 A。</p>
<p>抽象函数 AF必须是满射(即对每个 A 中的值，都有 R 中的值对应)，不一定是单射，也不一定是双射</p>
<p>表示不变性 RI：</p>
<ul>
<li>某个具体的“表示”是否合法</li>
<li>所有表示值的一个子集，包含了所有合法的表示值</li>
<li>一个条件，描述了什么是合法的表示值</li>
</ul>
<p>在所有可能改变 rep 的方法内部都需要检查 RI 是否满足，Observer 方法看情况。</p>
<p>对immutable的ADT来说，它在A空间的abstract value应是不变的。但其内部表示的R空间中的取值则可以是变化的，从这个角度来说，<strong>immutable 的 ADT 内部的 rep 是可以变化的</strong>。</p>
<p>代码中以注释形式写出 AF 与 RI 而不能在 javadoc 文档中，避免外部破坏。</p>
<h2 id="7-oop">7. oop<a hidden class="anchor" aria-hidden="true" href="#7-oop">#</a></h2>
<p>静态方法与实例方法</p>
<p>继承</p>
<p>重写与重载</p>
<h3 id="多态">多态<a hidden class="anchor" aria-hidden="true" href="#多态">#</a></h3>
<p>Ad-hoc 多态(特殊多态)：函数重载</p>
<p>参数化多态：使用泛型</p>
<p>子类型多态</p>
<p>重载与重写的区别:</p>
<ol>
<li>重载只是保持函数名字相同,函数参数,返回值,行为都可以不同</li>
<li>重写是子类型重写父类型的方法,函数签名一致,严格的编程规范要求子类型的实现规约强度大于等于父类型的实现</li>
<li>重载(overload)在编译阶段决定具体执行哪个方法,重写(overridden/overwrite)在运行时决定.</li>
</ol>
<p>重载:</p>
<ol>
<li>必须要求不同的参数列表</li>
<li>返回值类型不做要求</li>
<li>权限不做要求(private, public, protected)</li>
<li>抛出异常不做要求</li>
<li>可以在同一个类内重载，也可以在子类中重载</li>
</ol>
<p>注意:
在决定重载函数类型时,对于object参数类型的比较是基于静态类型,即编译时确定的类型,而不是对象实际的动态类型.</p>
<p>java @override (重写):</p>
<ol>
<li>参数列表必须完全相同，传入参数不能是父类型或子类型</li>
<li>返回类型与被重写方法返回类型可以不相同，但必须是父类返回值的派生类。</li>
<li>访问权限比父类方法更高</li>
<li>关于异常:<br>
可以减少抛出的异常,这样说明子类型的实现后置条件相对于父类型更强,规约也更强.<br>
不能抛出新的或者范围更广的异常,这样说明子类型不能处理这些输入,而父类型可以,规约强度减弱.</li>
<li>声明为 static 的方法不能被重写，但是能够被再次声明。</li>
</ol>
<p>对象静态类型与动态类型</p>
<h2 id="8-adt-与-oop-中的等价性">8. ADT 与 OOP 中的等价性<a hidden class="anchor" aria-hidden="true" href="#8-adt-与-oop-中的等价性">#</a></h2>
<p>等价关系：自反，对称，传递</p>
<h3 id="不可变类型的等价性">不可变类型的等价性<a hidden class="anchor" aria-hidden="true" href="#不可变类型的等价性">#</a></h3>
<ol>
<li>使用抽象函数判断等价性。</li>
<li>以观察者的角度：对两个对象调用任何相同的操作，结果相同，就认为等价。</li>
</ol>
<p><em>注意</em>,Java中,<code>==</code>是引用相等,它判断两个引用是否指向相同的对象,而<code>equals()</code>则比较两个对象是否相等.Java中<code>equals()</code>的默认实现是引用相等运算.</p>
<p>重写equals()的注意事项:</p>
<ul>
<li><code>equals</code>必须是一个等价关系.(非常重要,必须遵守)</li>
<li><code>equals</code>的结果必须一致,重复调用必须时必须产生相同的结果</li>
<li>对于非空的引用,<code>x.equals(null)</code>应该返回false</li>
<li><strong>两个对象在<code>equals</code>方法中被认为相等,那么它们在<code>hashCode</code>中的结果也应该被认为相等.</strong></li>
</ul>
<p>一个重要的准则:</p>
<blockquote>
<p>Always override hashCode when you override equals.</p>
</blockquote>
<p>java 根据静态类型选择最合适的函数。</p>
<p>严格来说，在没有AF的情况下直接在equals()中判断每个域的等价性，是不正确的</p>
<h4 id="instanceof">instanceof<a hidden class="anchor" aria-hidden="true" href="#instanceof">#</a></h4>
<p>Java中对于不同静态类型,而动态类型相同的相等运算,可能会产生错误.因此在实现时需要注意.我们可以使用<code>instanceof</code>关键字来获取对象的动态类型,但是除了<code>equals()</code>实现,在其他任何情况都应该避免使用.</p>
<p>使用 instanceof 是动态类型检查。</p>
<h4 id="hashcode">hashCode<a hidden class="anchor" aria-hidden="true" href="#hashcode">#</a></h4>
<p>hashCode 的默认实现返回对象内存地址。</p>
<p>可以使用 <code>Objects.hash()</code> 方法：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">hash</span><span style="color:#f92672">(</span>Object<span style="color:#f92672">...</span> values<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">return</span> Arrays<span style="color:#f92672">.</span><span style="color:#a6e22e">hashCode</span><span style="color:#f92672">(</span>values<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>可以将不可变类型的对象的成员变量传入，按照 Objects 数组的方式计算哈希值，这是一种重写 <code>hashCode()</code> 的方法。</p>
<h3 id="可变类型的等价性">可变类型的等价性<a hidden class="anchor" aria-hidden="true" href="#可变类型的等价性">#</a></h3>
<p>类似于不可变类型,对于可变类型,我们重新定义两种基于观察的等价性判别方法:</p>
<ul>
<li>观察等价性：在不改变状态的情况下，两个 mutable 对象是否看起来一致</li>
<li>行为等价性：调用对象的任何方法都展示出一致的结果。</li>
</ul>
<p><strong>这部分理解感觉还有点困难</strong>。</p>
<p>* 这部分的甄别比较重要</p>
<p>Java中,<code>List</code>,<code>Set</code>,<code>Map</code>等Collections使用观察等价性,而其他可变类如<code>StringBuilder</code>和数组,使用行为等价性。</p>
<p>例子：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">// 注意，虽然前面说 collections使用观察等价性，但是这里的代码是可以正常运行的。即使在之后往 list 中添加了其他的元素，对象前后的状态改变了
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span> <span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> argv<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    List<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> list <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">&lt;&gt;();</span>
    Set<span style="color:#f92672">&lt;</span>List<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;&gt;</span> test <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> HashSet<span style="color:#f92672">&lt;&gt;();</span>
    list<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;a&#34;</span><span style="color:#f92672">);</span>
    test<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>list<span style="color:#f92672">);</span>

    <span style="color:#66d9ef">assert</span> test<span style="color:#f92672">.</span><span style="color:#a6e22e">contains</span><span style="color:#f92672">(</span>list<span style="color:#f92672">);</span>
    list<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;google&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#66d9ef">assert</span> test<span style="color:#f92672">.</span><span style="color:#a6e22e">contains</span><span style="color:#f92672">(</span>list<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>一般来说，对于可变类型，不需要重写 <code>equals()</code> 与 <code>hashCode()</code>。</p>
<h3 id="基本类型的包装">基本类型的包装<a hidden class="anchor" aria-hidden="true" href="#基本类型的包装">#</a></h3>
<h2 id="9-面向复用的软件构造技术">9. 面向复用的软件构造技术<a hidden class="anchor" aria-hidden="true" href="#9-面向复用的软件构造技术">#</a></h2>
<p>复用：源代码级别，模块级别，库级别，系统级别</p>
<p>最主要的复用在代码层面</p>
<p>需求，设计/规约，数据，测试用例，文档等等都可以被复用</p>
<p>白盒复用：源代码可见，可修改可扩展。可定制化程度高</p>
<p>黑盒复用：源代码不可见，不能修改。通过简单的 API 接口使用，不能修改代码</p>
<p>工具：javap 获得类的公共方法头</p>
<table>
<thead>
<tr>
<th></th>
<th>白盒框架</th>
<th>黑盒框架</th>
</tr>
</thead>
<tbody>
<tr>
<td>扩展方式</td>
<td>通过代码层面的继承进行框架扩展</td>
<td>通过实现特定接口/委派进行框架扩展</td>
</tr>
<tr>
<td>设计模式</td>
<td>模板方法模式</td>
<td>策略模式，观察者模式</td>
</tr>
</tbody>
</table>
<h3 id="lsp-原则">LSP 原则<a hidden class="anchor" aria-hidden="true" href="#lsp-原则">#</a></h3>
<p>设计实现子类型多态时需要遵循的原则。</p>
<p>核心：子类型的规约强度必须强于父类型或与父类型一致。</p>
<p>更强的规约就要求：</p>
<ul>
<li>更强的不变量</li>
<li>更弱的前置条件</li>
<li>更强的后置条件</li>
</ul>
<p>要求：</p>
<ul>
<li>子类型可以增加方法，但不能删除</li>
<li>子类型需要实现抽象类型中的所有未实现方法</li>
<li>子类型中重写的方法必须有相同类型的返回值或者符合 co-variance 的返回值</li>
<li>子类型中重写的方法必须使用同类型的参数或者符合逆变的参数</li>
<li>子类型中重写的方法不能抛出额外的异常，抛出相同或者符合协变的异常</li>
</ul>
<p>父类型 -&gt; 子类型：越来越具体</p>
<p>协变：返回值，异常类型不变或更具体</p>
<p>反协变，逆变：返回值，异常类型不变或越来越抽象</p>
<p><em>注意</em>，java 中对于函数参数的逆变通常看做重载，即 overload</p>
<h4 id="泛型中的-lsp">泛型中的 LSP<a hidden class="anchor" aria-hidden="true" href="#泛型中的-lsp">#</a></h4>
<p><em>注意</em>，泛型不是<strong>协变</strong>。</p>
<p>由于存在类型擦除，因此运行时无法利用泛型参数进行类型推断。</p>
<p>重要的例子</p>
<ol>
<li>List&lt;Number&gt; is a subtype of List&lt;?&gt;</li>
<li>List&lt;Number&gt; is a subtype of List&lt;? extends Object&gt;</li>
<li>List&lt;Object&gt; is a subtype of List&lt;? super String&gt;</li>
</ol>
<h3 id="delegation-and-composition">Delegation and Composition<a hidden class="anchor" aria-hidden="true" href="#delegation-and-composition">#</a></h3>
<p>委派模式：通过运行时的动态类型绑定，实现对其他类中代码的复用。</p>
<p>委派简单来说，就是在一个类 A 中定义另一个类类型的成员变量 B，通过调用 B 的方法来实现想要的功能。</p>
<p>与继承相比，委派发生在 object 层面，而继承发生在 class 层面。</p>
<p>CRP 原则：在实现多态行为时，类应该选择持有实现需要的方法的类的实例，而不是在实现对应方法的类的基础上进行继承。简单来说，就是尽可能选择 has 或者 use 而不是 is 的方式。</p>
<p>CRP 原则更倾向于使用委派而不是继承来实现复用。</p>
<h3 id="types-of-delegation">Types of delegation<a hidden class="anchor" aria-hidden="true" href="#types-of-delegation">#</a></h3>
<ol>
<li>Dependency：临时性委派，即在程序过程中创建临时变量作为方法参数传递。</li>
<li>Association：永久性委派，在类中定义成员进行使用。</li>
<li>Composition：更强的 association，构造对象时直接创建对应的委派对象实例。</li>
<li>Aggregation：更弱的 association，在类中定义成员，在程序过程中使用类似于 <code>set()</code> 方法来设置成员变量，从而实现委派。</li>
</ol>
<p>Compositon 中，委派对象与本体会同时被破坏；但是在 Aggregation 中，委派对象的生命周期可能更长。</p>
<h2 id="10-面向可维护性的构造技术">10. 面向可维护性的构造技术<a hidden class="anchor" aria-hidden="true" href="#10-面向可维护性的构造技术">#</a></h2>
<p>MI(可维护性指数)影响因素：HV(Halstead Volume)，CC(代码圈复杂度)，LOC(模块平均代码行数)，COM(模块平均注释行数)</p>
<h3 id="模块设计及设计原则">模块设计及设计原则<a hidden class="anchor" aria-hidden="true" href="#模块设计及设计原则">#</a></h3>
<p>评估模块化的5个标准：可分解性，可组合性，可理解性，可持续性(变化时受影响范围最小)，异常保护(出现异常后受影响范围最小)</p>
<p>模块化设计的5条规则：直接映射，尽可能少的接口，尽可能小的接口，显式接口，信息隐藏</p>
<h4 id="couping耦合与-cohesion内聚">couping(耦合)与 cohesion(内聚)<a hidden class="anchor" aria-hidden="true" href="#couping耦合与-cohesion内聚">#</a></h4>
<p>耦合评估模块间的依赖程度。</p>
<p>内聚评估模块内功能或职责的关联程度。</p>
<p>软件开发追求高内聚，低耦合。</p>
<h3 id="面向对象的设计原则solid">面向对象的设计原则：SOLID<a hidden class="anchor" aria-hidden="true" href="#面向对象的设计原则solid">#</a></h3>
<ol>
<li>SRP(单一责任原则)：不应该由多于一个原因使 ADT 发生变化，否则就需要拆分 ADT。</li>
<li>OCP(开放/封闭原则)：对扩展性的开放，对修改的封闭</li>
<li>LSP：子类型必须能够替换基类型</li>
<li>ISP(接口隔离原则)：不能强迫客户端依赖于不需要的接口，只提供必需的接口</li>
<li>DIP(依赖转置原则)：抽象的模块不应该依赖于具体的模块。例：在实现委派的时候，通过接口建立联系，而不是直接定义对应类型的对象</li>
</ol>
<h2 id="11-设计模式">11. 设计模式<a hidden class="anchor" aria-hidden="true" href="#11-设计模式">#</a></h2>
<h3 id="1-创建型模式">1. 创建型模式<a hidden class="anchor" aria-hidden="true" href="#1-创建型模式">#</a></h3>
<h4 id="工厂方法模式">工厂方法模式<a hidden class="anchor" aria-hidden="true" href="#工厂方法模式">#</a></h4>
<p>使用场景：用户不知道创建哪个具体类的实例，或者不想再代码中指明要具体创建的实例时，可以使用工厂方法。</p>
<p>定义一个用于创建对象的接口，让其子类来决定实例化哪一个类，从而使类的实例化延迟到子类。</p>
<p>实现方法，定义一个工厂接口，工厂类中实现对应构造对象的方法。</p>
<p>符合 OCP 原则：对扩展开放，对修改已有代码封闭</p>
<h3 id="2-结构性模式">2. 结构性模式<a hidden class="anchor" aria-hidden="true" href="#2-结构性模式">#</a></h3>
<h4 id="适配器">适配器<a hidden class="anchor" aria-hidden="true" href="#适配器">#</a></h4>
<p>作用：将某个类/接口转换为用户期望的其他形式</p>
<p>实现方法：通过增加一个接口，将已存在的子类封装起来，用户面向接口编程，从而隐藏了具体子类。</p>
<h4 id="装饰器">装饰器<a hidden class="anchor" aria-hidden="true" href="#装饰器">#</a></h4>
<p>用每个子类实现不同的特性</p>
<p>实现方法：首先构造一个基类实现接口，接着构造一个装饰器类实现接口，装饰器类通过委派给基类的方式实现接口的方法。然后继承装饰器并在此基础上添加额外的功能。</p>
<h3 id="3行为类模式">3.行为类模式<a hidden class="anchor" aria-hidden="true" href="#3行为类模式">#</a></h3>
<h4 id="策略模式">策略模式<a hidden class="anchor" aria-hidden="true" href="#策略模式">#</a></h4>
<p>使用场景：有多种不同的算法实现同一个任务，但需要用户根据需要动态切换算法，而不是写死在代码中</p>
<p>实现方法：为不同的实现算法构造抽象接口，利用委派，运行时动态传入用户倾向的算法类实例。</p>
<h4 id="模板模式">模板模式<a hidden class="anchor" aria-hidden="true" href="#模板模式">#</a></h4>
<p>做事情的步骤一样，但是具体方法不同。</p>
<p>实现方法：共性的步骤在抽象类内公共实现，差异化的步骤在各个子类中实现</p>
<p>使用继承与重写实现模板模式</p>
<h4 id="迭代器">迭代器<a hidden class="anchor" aria-hidden="true" href="#迭代器">#</a></h4>
<p>使用场景：客户端希望遍历容器中的 ADT 对象，不关注容器具体类型</p>
<p>java 实现：</p>
<ul>
<li>需要实现继承 Iterable 接口的迭代器类，并且内部委派一个实现 Iterator 接口的类的对象。</li>
<li>Iterator 接口需要实现 <code>hasNext()</code>, <code>next()</code>，<code>remove()</code>(可选) 两/三个方法。</li>
</ul>
<h4 id="访问者模式">访问者模式<a hidden class="anchor" aria-hidden="true" href="#访问者模式">#</a></h4>
<p>对特定类型的对象的特定操作，运行时将两者动态绑定到一起，该操作可以灵活更改，无需更改被访问的类。</p>
<p>访问者模式本质上将数据和作用在数据上的某些特定操作分离。</p>
<p>访问者模式可以为 ADT 预留一个将来可扩展功能的接入点，外部实现的功能代码可以在不改变 ADT 本身的情况下通过委派接入 ADT。</p>
<p>实现方法(示例)：</p>
<ul>
<li>定义一个 Visitor 接口，包含 <code>visit()</code> 方法。</li>
<li>再定义一个 Accepter 接口，包含 <code>accept()</code> 方法。该方法传入一个 Visitor 参数。</li>
<li>将需要被访问的类实现 Accepter 接口，<code>accept()</code> 方法内部调用 <code>Visitor.visit(this)</code>。</li>
<li><code>visit()</code> 实现对访问对象的具体操作。</li>
</ul>
<p>注意：访问者模式也只能够使用对象的 public 成员与方法，对于私有成员/方法没有权限。</p>
<p>与策略模式的区别：</p>
<p>访问者模式站在外部用户的角度，灵活增加对 ADT 的不同操作。</p>
<p>策略模式是站在内部 ADT 的角度，对 ADT 的方法提供不同的实现策略，强调相应算法的灵活替换，这些算法被委派到外部的策略类中。</p>
<h2 id="12-面向正确性与健壮性的软件构造">12. 面向正确性与健壮性的软件构造<a hidden class="anchor" aria-hidden="true" href="#12-面向正确性与健壮性的软件构造">#</a></h2>
<p>正确性：永不给用户错误的结果，倾向于直接报错</p>
<p>健壮性：尽可能保证软件运行而不是总退出，倾向于容错</p>
<p>对外的接口，倾向于健壮；对内的接口，倾向于正确</p>
<p>外部观察角度：MTBF(平均失效间隔时间)</p>
<p>内部观察角度</p>
<p>Residual defect rates(残余缺陷率)<br>
KLOC：每千代码中遗留 bug 数量</p>
<h3 id="异常处理">异常处理<a hidden class="anchor" aria-hidden="true" href="#异常处理">#</a></h3>
<p>RuntimeException：运行时异常，unchecked，继承自 Exception，不需要被捕获。</p>
<p><strong>如果父类型中的方法没有抛出异常，那么子类型中的方法必须捕获所有的checked exception。</strong></p>
<h4 id="final">final<a hidden class="anchor" aria-hidden="true" href="#final">#</a></h4>
<p>在抛出异常之后，方法中正常执行的代码被终止。一些申请过的资源需要被清理。这时我们可以使用 final。无论程序中是否有异常，final 块中的代码一定会被执行。</p>
<p>一个重要的例子：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">decision</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;here&#34;</span><span style="color:#f92672">);</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span> <span style="color:#66d9ef">finally</span> <span style="color:#f92672">{</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;return&#34;</span><span style="color:#f92672">);</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> argv<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>decision<span style="color:#f92672">());</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>最后的输出：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">here
<span style="color:#66d9ef">return</span>
<span style="color:#66d9ef">false</span>
</code></pre></div><h3 id="assertion">assertion<a hidden class="anchor" aria-hidden="true" href="#assertion">#</a></h3>
<p>检查前置条件是防御式编程的一种典型形式</p>
<p>在实际使用时，assertion 都会被 disabled</p>
<p><code>assert condition : message;</code> 在 assertion 错误时会显示 message。</p>
<p>assertion 主要用于开发阶段，避免引入和帮助发现bug。在开发时 assertion 编译入代码，生产中从代码剥离，因此不会降低性能。assertion 非常影响运行时性能。</p>
<p>assertion -&gt; 正确性<br>
exception -&gt; 健壮性</p>
<h3 id="防御式编程">防御式编程<a hidden class="anchor" aria-hidden="true" href="#防御式编程">#</a></h3>
<ol>
<li>排除非法输入</li>
<li>assertions</li>
<li>exceptions</li>
<li>specific error handling techniques</li>
<li>barricade</li>
<li>debugging aids</li>
</ol>
<p>工具： FindBugs，SpotBugs。都是使用静态代码分析找出程序中的 bug。</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://ognimalf.github.io/tags/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0/">软件构造</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<script src="https://cdn.bootcss.com/mermaid/8.0.0-rc.8/mermaid.min.js"></script>
<footer class="footer">
    <span>&copy; 2022 <a href="https://ognimalf.github.io">Salieri&#39;s Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = 'copy';

        function copyingDone() {
            copybutton.innerText = 'copied!';
            setTimeout(() => {
                copybutton.innerText = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
